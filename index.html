<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chase Game</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: black;
      font-family: Arial, sans-serif;
      color: white;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: none;
    }

    #ghostImage, #enemyImage, #wizardImage {
      display: none;
    }

    /* Start menu styles */
    #startMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      font-size: 24px;
    }

    #startMenu button {
      font-size: 20px;
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      margin: 10px 0;
    }

    #startMenu button:hover {
      background-color: #45a049;
    }

    #description {
      font-size: 18px;
      max-width: 400px;
      margin: 20px auto;
      display: none;
    }

    #toggleDescription {
      font-size: 18px;
      color: #4CAF50;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="startMenu">
    <h1>Welcome to the Chase Game</h1>
    <button id="startButton">Start Game</button>
    <div id="toggleDescription">Read about the game</div>
    <p id="description">
      In this game, you control a ghost that follows the cursor or tap location. 
      You need to avoid enemies and wizards while trying to increase your score. 
      Enemies will flee from the ghost, and wizards will chase it. The game ends if you reach a certain score or get caught by a wizard.
    </p>
  </div>
  
  <canvas id="gameCanvas"></canvas>
  <img id="ghostImage" src="ghost.png" alt="Ghost" />
  <img id="enemyImage" src="Run.png" alt="Enemy" />
  <img id="wizardImage" src="RunWizard.png" alt="Wizard" />
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const ghostImage = document.getElementById('ghostImage');
    const enemyImage = document.getElementById('enemyImage');
    const wizardImage = document.getElementById('wizardImage');

    const bgImage = new Image();
    bgImage.src = 'terrace.png';

    let ghost = {
      x: 0,
      y: 0,
      speed: 4,
      width: 50,
      height: 50,
      targetX: 0,  // Target X for ghost animation
      targetY: 0   // Target Y for ghost animation
    };

    let prevGhost = { x: ghost.x, y: ghost.y };
    let ghostVelocity = { x: 0, y: 0 };

    let enemies = [];
    let wizards = [];
    let score = 0;
    let gameOver = false;
    let gameStarted = false;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Start button click event to start the game
    document.getElementById('startButton').addEventListener('click', startGame);

    // Toggle description visibility
    document.getElementById('toggleDescription').addEventListener('click', () => {
      const description = document.getElementById('description');
      if (description.style.display === 'none') {
        description.style.display = 'block';
        document.getElementById('toggleDescription').innerText = 'Hide the description';
      } else {
        description.style.display = 'none';
        document.getElementById('toggleDescription').innerText = 'Read about the game';
      }
    });

    function startGame() {
      document.getElementById('startMenu').style.display = 'none'; // Hide the start menu
      gameStarted = true;
      update(); // Start the game loop
    }

    // Follow the cursor
    document.addEventListener('mousemove', (e) => {
      if (gameStarted) {
        ghost.targetX = e.clientX - ghost.width / 2;
        ghost.targetY = e.clientY - ghost.height / 2;
      }
    });

    // Animate ghost to touch position
    document.addEventListener('touchstart', (e) => {
      if (gameStarted) {
        const touch = e.touches[0]; // Get the first touch
        ghost.targetX = touch.clientX - ghost.width / 2;
        ghost.targetY = touch.clientY - ghost.height / 2;
      }
    });

    const enemySprite = {
      x: -50,
      y: Math.random() * canvas.height,
      width: 128,
      height: 128,
      baseSpeed: Math.random() * 1.5 + 1.5,
      frame: 0,
      totalFrames: 8,
      angle: 0,
      updateFrame: function () {
        this.frame = (this.frame + 1) % this.totalFrames;
      }
    };

    const wizardSprite = {
      x: -50,
      y: Math.random() * canvas.height,
      width: 128,
      height: 128,
      baseSpeed: Math.random() * 1.5 + 1.5,
      frame: 0,
      totalFrames: 8,
      angle: 0,
      updateFrame: function () {
        this.frame = (this.frame + 1) % this.totalFrames;
      }
    };

    function spawnEnemy() {
      const enemy = Object.create(enemySprite);
      enemy.x = -50;
      enemy.y = Math.random() * canvas.height;
      enemy.angle = 0;
      enemy.baseSpeed = Math.random() * 1.5 + 1.5;
      enemies.push(enemy);
    }

    function spawnWizard() {
      const wizard = Object.create(wizardSprite);
      wizard.x = -50;
      wizard.y = Math.random() * canvas.height;
      wizard.angle = 0;
      wizard.baseSpeed = Math.random() * 1.5 + 1.5;
      wizards.push(wizard);
    }

    function update() {
      if (!gameStarted) return;

      if (gameOver) {
        ctx.fillStyle = 'white';
        ctx.font = '48px Arial';
        ctx.fillText('Game Over!', canvas.width / 2 - 120, canvas.height / 2);
        return;
      }

      // Ghost animation towards target position (tap location)
      const dx = ghost.targetX - ghost.x;
      const dy = ghost.targetY - ghost.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > 1) {
        const angle = Math.atan2(dy, dx);
        ghost.x += Math.cos(angle) * ghost.speed;
        ghost.y += Math.sin(angle) * ghost.speed;
      }

      // Update ghost velocity
      ghostVelocity.x = ghost.x - prevGhost.x;
      ghostVelocity.y = ghost.y - prevGhost.y;
      prevGhost.x = ghost.x;
      prevGhost.y = ghost.y;

      // Draw background
      ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);

      const circleRadius = 300;
      const fadeRadius = 250;
      const centerX = ghost.x + ghost.width / 2;
      const centerY = ghost.y + ghost.height / 2;

      // Spotlight mask
      const gradient = ctx.createRadialGradient(centerX, centerY, fadeRadius, centerX, centerY, circleRadius);
      gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw ghost with glow
      ctx.shadowColor = 'white';
      ctx.shadowBlur = 15;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      ctx.drawImage(ghostImage, ghost.x, ghost.y, ghost.width, ghost.height);
      ctx.shadowColor = 'transparent';

      // Update and draw enemies (People) - Flee from ghost
      enemies.forEach((enemy, index) => {
        const dx = ghost.x - enemy.x;
        const dy = ghost.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Calculate the angle towards the ghost
        let enemyAngle = Math.atan2(dy, dx);

        // Rotate 180 degrees to make the enemy face the opposite direction
        enemyAngle += Math.PI; // Add 180 degrees (Math.PI radians)

        // If the enemy is close to the ghost, flip direction and move away
        if (distance <= 300) {  // Adjust the distance to your preference
          const angleToGhost = Math.atan2(dy, dx);
          const fleeDirectionX = -Math.cos(angleToGhost + Math.PI);  // Flip direction by adding Math.PI
          const fleeDirectionY = -Math.sin(angleToGhost + Math.PI);  // Flip direction by adding Math.PI

          const fleeSpeed = enemy.baseSpeed + 3 * (1 - distance / 200); // Flee faster as they get closer
          enemy.x -= fleeDirectionX * fleeSpeed;
          enemy.y -= fleeDirectionY * fleeSpeed;
        } else {
          // Otherwise, move towards the general direction (same as before)
          enemy.x += enemy.baseSpeed;
        }

        if (distance <= circleRadius) {
          enemy.updateFrame();
          ctx.save();
          ctx.translate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2); // Move to the center of the enemy
          ctx.rotate(enemyAngle); // Rotate the enemy to face the opposite direction of the ghost
          ctx.drawImage(
            enemyImage,
            enemy.frame * enemy.width, 0,
            enemy.width, enemy.height,
            -enemy.width / 2, -enemy.height / 2,
            enemy.width, enemy.height
          );
          ctx.restore();
        }

        // Remove enemy if out of bounds
        if (
          enemy.x > canvas.width || enemy.x < -enemy.width ||
          enemy.y > canvas.height || enemy.y < -enemy.height
        ) {
          enemies.splice(index, 1);
        }

        // Handle collision with ghost (same as before)
        if (
          ghost.x < enemy.x + enemy.width &&
          ghost.x + ghost.width > enemy.x &&
          ghost.y < enemy.y + enemy.height &&
          ghost.y + ghost.height > enemy.y
        ) {
          score++;
          enemies.splice(index, 1);
          if (score >= 5) {
            gameOver = true;
          }
        }
      });

      // Update and draw wizards (always move towards the ghost)
      wizards.forEach((wizard, index) => {
        const dx = ghost.x - wizard.x;
        const dy = ghost.y - wizard.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Calculate the angle towards the ghost
        wizard.angle = Math.atan2(dy, dx);

        const ghostDir = { x: ghost.x - wizard.x, y: ghost.y - wizard.y }; // Move towards ghost
        const mag = Math.sqrt(ghostDir.x ** 2 + ghostDir.y ** 2) || 1;
        ghostDir.x /= mag;
        ghostDir.y /= mag;

        wizard.x += ghostDir.x * wizard.baseSpeed;
        wizard.y += ghostDir.y * wizard.baseSpeed;

        if (distance <= circleRadius) {
          wizard.updateFrame();
          ctx.save();
          ctx.translate(wizard.x + wizard.width / 2, wizard.y + wizard.height / 2); // Move to the center of the wizard
          ctx.rotate(wizard.angle); // Rotate the wizard towards the ghost
          ctx.drawImage(
            wizardImage,
            wizard.frame * wizard.width, 0,
            wizard.width, wizard.height,
            -wizard.width / 2, -wizard.height / 2,
            wizard.width, wizard.height
          );
          ctx.restore();
        }

        if (
          wizard.x > canvas.width || wizard.x < -wizard.width ||
          wizard.y > canvas.height || wizard.y < -wizard.height
        ) {
          wizards.splice(index, 1);
        }

        if (
          ghost.x < wizard.x + wizard.width &&
          ghost.x + ghost.width > wizard.x &&
          ghost.y < wizard.y + wizard.height &&
          ghost.y + ghost.height > wizard.y
        ) {
          score--; // Subtract from score when wizard collides
          wizards.splice(index, 1);
        }
      });

      // Randomly spawn enemies and wizards
      if (Math.random() < 0.01) {
        spawnEnemy();
      }

      if (Math.random() < 0.005) { // Less frequent spawn rate for wizard
        spawnWizard();
      }

      ctx.fillStyle = 'white';
      ctx.font = '24px Arial';
      ctx.fillText('Score: ' + score, 20, 30);

      requestAnimationFrame(update);
    }

    bgImage.onload = () => {
      update();
    };
  </script>
</body>
</html>
